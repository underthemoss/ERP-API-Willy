#!/usr/bin/env node

/**
 * Generate type-safe test utilities from ksqlDB state.json
 * This script reads the state.json file and generates TypeScript types and helper functions
 * for type-safe testing of ksqlDB tables and streams.
 */

import * as fs from 'fs';
import * as path from 'path';

// Type definitions for ksqlDB schema
interface SchemaField {
  name: string;
  schema: Schema;
  type?: string;
}

interface Schema {
  type: string;
  memberSchema?: Schema;
  fields?: SchemaField[];
}

interface TableDescription {
  type: string;
  fields: SchemaField[];
}

interface StateJson {
  descriptions: Record<string, TableDescription>;
}

// Type mapping from ksqlDB types to TypeScript types
const typeMap: Record<string, string> = {
  STRING: 'string',
  INTEGER: 'number',
  BIGINT: 'number',
  DOUBLE: 'number',
  BOOLEAN: 'boolean',
  BYTES: 'string',
};

/**
 * Convert a ksqlDB schema to a TypeScript type
 */
function schemaToTypeScript(schema: Schema | undefined, depth: number = 0): string {
  if (!schema) return 'any';

  switch (schema.type) {
    case 'STRING':
    case 'INTEGER':
    case 'BIGINT':
    case 'DOUBLE':
    case 'BOOLEAN':
    case 'BYTES':
      return `${typeMap[schema.type]} | null`;

    case 'ARRAY':
      if (schema.memberSchema) {
        return `Array<${schemaToTypeScript(schema.memberSchema, depth + 1)}>`;
      }
      return 'Array<any>';

    case 'STRUCT':
      if (schema.fields && Array.isArray(schema.fields)) {
        const fields = schema.fields
          .map((field) => {
            const fieldType = schemaToTypeScript(field.schema, depth + 1);
            return `${field.name}?: ${fieldType}`;
          })
          .join(';\n' + '  '.repeat(depth + 2));
        return `{\n${'  '.repeat(depth + 2)}${fields}\n${'  '.repeat(depth + 1)}}`;
      }
      return 'Record<string, any>';

    default:
      return 'any';
  }
}

/**
 * Extract the primary key field name from table fields
 */
function extractKeyField(fields: SchemaField[]): string {
  const keyField = fields.find((f) => f.type === 'KEY');
  return keyField ? keyField.name : 'id';
}

/**
 * Generate the TableSchemas interface
 */
function generateTableSchemas(descriptions: Record<string, TableDescription>): string {
  const tables = Object.entries(descriptions)
    .filter(([, desc]) => desc.type === 'TABLE')
    .sort(([a], [b]) => a.localeCompare(b));

  const schemas = tables
    .map(([tableName, tableDesc]) => {
      const keyField = extractKeyField(tableDesc.fields);
      const keySchema = tableDesc.fields.find((f) => f.name === keyField)?.schema;
      const keyType = keySchema ? schemaToTypeScript(keySchema) : 'string | null';

      const valueFields = tableDesc.fields
        .filter((f) => f.type !== 'KEY')
        .map((field) => {
          const fieldType = schemaToTypeScript(field.schema, 1);
          return `${field.name}?: ${fieldType}`;
        })
        .join(';\n    ');

      return `  ${tableName}: {
    ${keyField}: ${keyType};
${valueFields ? '\n    ' + valueFields : ''}
  }`;
    })
    .join(';\n\n');

  return `export type TableSchemas = {\n${schemas}\n};`;
}

/**
 * Generate the tableKeys constant
 */
function generateTableKeys(descriptions: Record<string, TableDescription>): string {
  const tables = Object.entries(descriptions)
    .filter(([, desc]) => desc.type === 'TABLE')
    .sort(([a], [b]) => a.localeCompare(b));

  const keys = tables
    .map(([tableName, tableDesc]) => {
      const keyField = extractKeyField(tableDesc.fields);
      return `  ${tableName}: '${keyField}'`;
    })
    .join(',\n\n');

  return `const tableKeys = {\n${keys},\n};`;
}

/**
 * Generate the complete test utilities file
 */
function generateTestUtils(stateJson: StateJson): string {
  const { descriptions } = stateJson;

  const tableSchemas = generateTableSchemas(descriptions);
  const tableKeys = generateTableKeys(descriptions);

  return `// This file was auto-generated by scripts/generate-test-utils.ts
// Do not edit this file directly

import KsqldbClient from 'ksqldb-client';

import { mapValues, mapKeys, isObject, isArray } from 'lodash';

export const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export function escapeKeysDeep(obj: Record<string, any>): Record<string, any> {
  const escapeKey = (_: any, key: string) => {
    return \`\\\`\${key}\\\`\`;
  };

  if (isArray(obj)) {
    return obj.map((innerObj) => escapeKeysDeep(innerObj));
  } else if (isObject(obj)) {
    return mapValues(mapKeys(obj, escapeKey), (val) => escapeKeysDeep(val));
  } else {
    return obj;
  }
}

function isLowerCase(str: string) {
  return str === str.toLowerCase() && str !== str.toUpperCase();
}

${tableSchemas}

${tableKeys}

// Helper to parse ksqlDB endpoint URL into host and port
function parseKsqlEndpoint(endpoint: string = 'http://localhost:8088'): { host: string; port: number } {
  const url = new URL(endpoint);
  return {
    host: url.hostname,
    port: parseInt(url.port) || 8088
  };
}

export const table = <T extends keyof TableSchemas>(
  name: T
): {
  insert: (value: TableSchemas[T]) => Promise<void>;
  get: (id: string | number) => Promise<TableSchemas[T]>;
  getMany: (id: string | number, fields?: string) => Promise<TableSchemas[T][]>;
  tombstone: (id: string | number | object) => Promise<void>;
} => {
  return {
    insert: async (value: TableSchemas[T]) => {
      const { host, port } = parseKsqlEndpoint(process.env.KSQLDB_ENDPOINT);
      const client = new KsqldbClient({ host, port });
      try {
        await client.connect();
        const escapedRow = escapeKeysDeep(value);
        const { error, status } = await client.insertInto(name, escapedRow);
        if (error) {
          console.log('Error in insertInto', status);
          console.error(error);
          throw error;
        }
      } catch (err) {
        throw new Error(\`Could not insertInto \${name}\`);
      } finally {
        await client.disconnect();
      }
    },
    get: async (id: string | number) => {
      const { host, port } = parseKsqlEndpoint(process.env.KSQLDB_ENDPOINT);
      const client = new KsqldbClient({ host, port });

      let key = tableKeys[name];
      if (isLowerCase(key)) {
        key = \`\\\`\${key}\\\`\`;
      }
      let wherePredicate;
      if (typeof id === 'string') {
        wherePredicate = \`\${key} = '\${id}'\`;
      } else {
        wherePredicate = \`\${key} = \${id}\`;
      }
      const query = \`select * from \${name} where \${wherePredicate};\`;
      try {
        await client.connect();
        const [data] = await client.query(query).then(({ data, error }) => {
          if (error) throw error;
          return data?.rows as any[];
        });
        return data as TableSchemas[T];
      } finally {
        await client.disconnect();
      }
    },
    getMany: async (id: string | number, fields: string = '*') => {
      const { host, port } = parseKsqlEndpoint(process.env.KSQLDB_ENDPOINT);
      const client = new KsqldbClient({ host, port });

      let key = tableKeys[name];
      if (isLowerCase(key)) {
        key = \`\\\`\${key}\\\`\`;
      }
      let wherePredicate;
      if (typeof id === 'string') {
        wherePredicate = \`\${key} = '\${id}';\`;
      } else {
        wherePredicate = \`\${key} = \${id};\`;
      }
      const query = \`select \${fields} from \${name} where \${wherePredicate}\`;
      try {
        await client.connect();
        const data = await client.query(query).then(({ data, error }) => {
          if (error) throw error;
          return data?.rows as any[];
        });
        return data as TableSchemas[T][];
      } finally {
        await client.disconnect();
      }
    },
    tombstone: async (id: string | number | object) => {
      // 1. Get topic name and key format from ksqlDB
      const { host, port } = parseKsqlEndpoint(process.env.KSQLDB_ENDPOINT);
      const ksqlClient = new KsqldbClient({ host, port });
      let topic: string;
      let keyFormat: string;
      
      try {
        await ksqlClient.connect();
        const sourceDesc = await ksqlClient.describeSource(name);
        topic = sourceDesc.topic;
        keyFormat = sourceDesc.keyFormat;
      } finally {
        await ksqlClient.disconnect();
      }
      
      // 2. Format the key based on KEY_FORMAT
      const { execSync } = require('child_process');
      let key: string;
      
      if (keyFormat === 'JSON') {
        // For JSON key format, serialize the value as JSON
        // This adds quotes around strings: "value" instead of value
        key = JSON.stringify(typeof id === 'object' ? id : String(id));
      } else {
        // For STRING keys (or other formats), use plain string
        key = String(id);
      }
      
      // 3. Send tombstone via docker exec + rpk (avoids Docker networking issues)
      // Get Redpanda container ID from global setup
      const redpandaContainer = (global as any).__KSQL_REDPANDA__;
      if (!redpandaContainer) {
        throw new Error('Redpanda container not found in global context');
      }
      
      const containerId = redpandaContainer.getId();
      
      // Use rpk with -Z flag to produce tombstone (null value)
      // The -Z flag makes rpk treat empty values as tombstones (null)
      // Escape the key for shell
      const escapedKey = key.replace(/"/g, '\\\\"');
      execSync(
        \`echo "" | docker exec -i \${containerId} rpk topic produce \${topic} --key "\${escapedKey}" -Z\`,
        { stdio: 'inherit' }
      );
    },
  };
};

export const retry = async (action: () => void) => {
  for (let i = 0; i <= 40; i++) {
    try {
      await action();
      break;
    } catch (err) {
      if (i === 40) {
        throw err;
      }
      await sleep(100);
    }
  }
};
`;
}

/**
 * Main execution
 */
export function main(): void {
  const stateJsonPath = path.join(__dirname, '..', 'state.json');
  const outputPath = path.join(__dirname, '..', 'tests', 'utils', 'test-helpers.generated.ts');

  // Read state.json
  console.log('Reading state.json...');
  const stateJson: StateJson = JSON.parse(fs.readFileSync(stateJsonPath, 'utf8'));

  // Generate test utilities
  console.log('Generating type-safe test utilities...');
  const testUtils = generateTestUtils(stateJson);

  // Write output file
  console.log(`Writing to ${outputPath}...`);
  fs.writeFileSync(outputPath, testUtils, 'utf8');

  // Run prettier on the generated file
  console.log('Running prettier...');
  const { execSync } = require('child_process');
  try {
    execSync(`npx prettier --write ${outputPath}`, { stdio: 'inherit' });
  } catch (error) {
    console.warn('Warning: Prettier formatting failed, but file was generated successfully');
  }

  console.log('âœ… Type-safe test utilities generated successfully!');
}

// Run the script
if (require.main === module) {
  main();
}
